"""Threading example."""
import itertools
import time
from threading import Thread, Event


def spin(msg: str, done: Event) -> None:
    """
    Эта функция будет работать в отдельном потоке. Аргумент done, экземпляр
    класса threading.Event , – простой объект для синхронизации потоков.
    """
    for char in itertools.cycle(r'\|/-'):  # 2
        status = f'\r{char} {msg}'  # 3
        print(status, end='', flush=True)
        if done.wait(.15):  # 4
            break  # 5
        blanks = ' ' * len(status)
        print(f'\r{blanks}\r', end='')  # 6


def slow() -> int:
    """
    Функция slow() вызывается из главного потока. Представьте, что это вызов
    медленного API по сети. Вызов sleep блокирует главный поток, но GIL при
    этом освобождается, поэтому поток индикатора продолжает работать.
    """
    time.sleep(3)
    # В этом примере нужно обратить внимание на то, что time.sleep()
    # блокирует вызывающий поток, но освобождает GIL, позволяя
    # работать другим потокам Python.
    return 42


# 2
# Это бесконечный цикл, потому что itertools.cycle отдает по одному символу
# за раз и перебирает заданную строку по кругу.

# 3
# Хитрость, позволяющая выполнить анимацию в текстовом режиме: воз-
# вращаем курсор в начало строки, печатая управляющий символ возврата
# каретки ( '\r' ).

# 4
# Метод Event.wait(timeout=None) возвращает True , когда другой поток установил
# событие; если же истек тайм-аут timeout , то он возвращает False . Тайм-аут
# .1s означает, что анимация производится с частотой 10 кадров в секунду.
# Чтобы индикатор крутился быстрее, задайте тайм-аут поменьше.

# 5
# Выйти из бесконечного цикла.

# 6
# Очистить строку состояния, затирая ее пробелами и возвращая курсор
# в начало строки.


def supervisor() -> int:  # 1
    done = Event()  # 2
    spinner = Thread(target=spin, args=('thinking!', done))  # 3
    print(f'spinner object: {spinner}')  # 4
    spinner.start()  # 5
    result = slow()  # 6
    done.set()  # 7
    spinner.join()  # 8
    return result


def main() -> None:
    result = supervisor()  # 9
    print(f'Answer: {result}')


if __name__ == '__main__':
    main()

# 1
# supervisor возвращает результат slow

# 2
# Экземпляр threading.Event – ключ к координации потоков main и spinner , как
# будет объяснено ниже.

# 3
# Чтобы создать новый экземпляр Thread , задайте функцию в именованном
# аргументе target , а необходимые ей позиционные аргументы передавайте
# в кортеже args.

# 4
# Отобразить объект spinner. Результатом будет представление <Thread(Thread-1,
# initial)> , где initial – состояние потока, означающее, что он еще не запущен.

# 5
# Запустить поток spinner.

# 6
# Вызвать функцию slow , которая блокирует поток main. Тем временем второй
# поток выполняет анимацию индикатора.

# 7
# Установить флаг Event в True ; в результате произойдет выход из цикла for
# в функции spin.

# 8
# Ждать завершения потока spinner .

# 9
# Вызвать функцию supervisor . Я разделил функции main и supervisor , чтобы
# этот пример больше походил на версию с asyncio.