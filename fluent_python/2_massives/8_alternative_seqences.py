"""Когда список не подходит"""

# memoryview – это тип последовательности в общей памяти,
# который позволяет работать со срезами массивов, ничего не копируя.
# array - если требуется сохранить 10 миллионов чисел с плавающей точкой
# deque - если вы часто добавляете и удаляе­те элементы из того или другого конца  # noqa: E501
# set - Если в программе много проверок на вхождение
# Множества оптимизированы для быстрой проверки вхождения.

from array import array
from random import random


floats = array('d', (random() for _ in range(10**7)))  # support creation from generators  # noqa: E501
print(floats[-1])
with open('floats.bin', 'wb') as file:
    floats.tofile(file)
floats2 = array('d')
with open('floats.bin', 'rb') as file:
    floats2.fromfile(file, 10**7)
# Это почти в 60 раз быстрее чтения из текстового файла,
# когда требуется разбирать каждую строку встроенной функцией float.
# размер двоичного файла с 10 миллионами чисел двойной точности составляет
# 80 000 000 байт (по 8 байт на число, с нулевыми накладными расходами), а
# текстового файла с теми же данными – 181 515 739 байт.
print(floats[-1])
print(floats == floats2)

"""
Чтобы отсортировать массив, вос-
пользуйтесь встроенной функцией sorted, которая перестраива-
ет массив:
a = array.array(a.typecode, sorted(a))
"""

###############################
# Представления областей памяти
###############################
octets = array('B', range(6))
m1 = memoryview(octets)
print(m1.tolist())
[0, 1, 2, 3, 4, 5]

m2 = m1.cast('B', [2, 3])
print(m2.tolist())
[[0, 1, 2], [3, 4, 5]]

m3 = m1.cast('B', [3, 2])
print(m3.tolist())
[[0, 1], [2, 3], [4, 5]]

m2[1, 1] = 22  # Перезаписать байт в строке 1, столбце 1 представления m2 значением 22.  # noqa: E501
m3[1, 1] = 33  # Перезаписать байт в строке 1, столбце 1 представления m3 значением 33.  # noqa: E501
print(octets)
# Отобразить исходный массив, доказав тем самым, что octets , m1 , m2 и m3 ис-
# пользовали одну и ту же память.
array('B', [0, 1, 2, 33, 22, 51])
