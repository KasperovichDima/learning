"""NumPy"""
from time import perf_counter

import numpy


# Простые операции со строками и столбцами из модуля numpy.ndarray
a = numpy.arange(12)
print(a)
print(type(a))
print(a.shape)  # Распечатать размерности массива: это одномерный массив с 12 элементами.  # noqa: E501
# (12, )
a.shape = 3, 4  # Изменить форму массива, добавив еще одно измерение.
print(a)
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]
print(a[2])
# [ 8  9 10 11]
print(a[2, 1])  # Получить элемент с индексами 2, 1
# 9
print(a[:, 1])  # Получить столбец с индексом 1.
# [1 5 9]
print(a.transpose())  # Создать новый массив, транспонировав исходный -
                      # (т. е. переставив местами строки и столбцы).  # noqa
# [[ 0  4  8]
#  [ 1  5  9]
#  [ 2  6 10]
#  [ 3  7 11]]


# NumPy также поддерживает загрузку, сохранение и применение операций
# сразу ко всем элементам массива numpy.ndarray :

# Загрузить 10 миллионов чисел с плавающей точкой из текстового файла.
floats = numpy.loadtxt('floats-10M-lines.txt')

# С помощью нотации получения среза распечатать последние три числа.
floats[-3:]
# array([ 3016362.69195522, 535281.10514262, 4566560.44373946])

# Умножить каждый элемент массива floats на 0.5 и снова распечатать по-
# следние три элемента.
floats *= .5
floats[-3:]
# array([ 1508181.34597761, 267640.55257131, 2283280.22186973])

# Разделить каждый элемент на 3; для 10 миллионов чисел с плавающей точ-
# кой это заняло менее 40 миллисекунд.
t0 = perf_counter()
floats /= 3
print(perf_counter() - t0)
# 0.03690556302899495

# Сохранить массив в двоичном файле с расширением .npy
numpy.save('floats-10M', floats)

# Загрузить данные в виде спроецированного на память файла в другой мас-
# сив; это позволяет эффективно обрабатывать срезы массива, хотя он и не
# находится целиком в памяти.
floats2 = numpy.load('floats-10M.npy', 'r+')

# Умножить все элементы на 6 и распечатать последние три.
floats2 *= 6
floats2[-3:]
# memmap([ 3016362.69195522, 535281.10514262, 4566560.44373946])
