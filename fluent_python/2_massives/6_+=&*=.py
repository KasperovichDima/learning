"""С оставное присваивание последовательностей"""


"""
Если объект a реализует метод __iadd__ , то он и будет вызван. В случае из-
меняемых последовательностей (например, list , bytearray , array.array ) a будет
изменен на месте (результат получается такой же, как при вызове a.extend(b) ).
Если же a не реализует __iadd__ , то выражение a += b вычисляется так же, как
a = a + b , т. е. сначала вычисляется a + b и получившийся в результате новый
объект связывается с переменной a . Иными словами, идентификатор объек-
та a остается тем же самым или становится другим в зависимости от наличия
метода __iadd__ .
"""

l = [1, 2, 3]
id(l)
# 4311953800 
l *= 2
l
# [1, 2, 3, 1, 2, 3]
id(l)
# 4311953800
t = (1, 2, 3)
id(t)
# 4312681568
t *= 2
id(t)
# 4301348296

"""
Кратная конкатенация неизменяемых последовательностей выполняется
неэффективно, потому что вместо добавления новых элементов интерпрета-
тор вынужден копировать всю конечную последовательность, чтобы создать
новую с добавленными элементами.
Тип str – исключение из этого правила. Поскольку построение строки с помощью
оператора += в цикле - весьма распространенная операция, в CPython этот случай
оптимизирован. Экземпляры str создаются с запасом памяти, чтобы при конкатенации
не приходилось каждый раз копировать всю строку.
"""
