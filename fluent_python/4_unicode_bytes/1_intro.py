"""О символах , и не только"""


# Кодирование и декодирование
s = 'café'
b = s.encode('utf8')
print(b)
# b'caf\xc3\xa9'
# Литералы типа bytes начинаются префиксом b
# первые три байта b'caf' принадлежат диапазону символов ASCII с графическим
# начертанием, последний – нет.
print(len(b))
# 5
s = b.decode('utf8')
print(s)
# café


"""
Главное, что нужно знать, - это то, что существуют два
основных встроенных типа двоичных последовательностей: неизменяемый
тип bytes , появившийся в Python 3, и изменяемый тип bytearray , добавленный
в Python 2.6. Каждый элемент bytes или bytearray - целое число от 0 до 255.
Однако срез двоичной последовательности всегда является двоичной
последовательностью того же типа, даже если это срез длины.
"""
# bytes можно получить из str , если известна кодировка
cafe = bytes('café', encoding='utf_8')
print(cafe[0])
# 99 Каждый элемент – целое число в диапазоне range(256)
print(cafe[:1])
# b'c' Срезы bytes также имеют тип bytes , даже если срез состоит из одного
# байта.
cafe_arr = bytearray(cafe)
print(cafe_arr)
# bytearray(b'caf\xc3\xa9')
print(cafe_arr[-1:])
# bytearray(b'\xa9') Срез bytesarray также имеет тип bytesarray

"""
Оба типа, bytes и bytearray , поддерживают все методы типа str , кроме тех,
что относятся к форматированию ( format , format_map ), и еще нескольких.
К двоичным последовательностям применимы и функции для работы с регулярными
выражениями из модуля re/."""

"""
Для двоичных последовательностей существует метод класса, отсутствую-
щий в типе str : fromhex , который строит последовательность, разбирая пары
шестнадцатеричных цифр.
"""
x = bytes.fromhex('31 4B CE A9')
print(x)
# b'1K\xce\xa9'
print(x.decode('utf8'))
# 1KΩ

"""
Другие способы построения объектов bytes и bytearray связаны с вызовом
различных конструкторов:
 с именованными аргументами str и encoding ;
 с итерируемым объектом, порождающим элементы со значениями от 0
до 255;
 с объектом, который реализует протокол буфера (например, bytes ,
bytearray , memoryview , array.array ), при этом байты копируются из исходного
объекта во вновь созданную двоичную последовательность.
"""

# Инициализация байтов данными, хранящимися в массиве
import array
numbers = array.array('h', [-2, -1, 0, 1, 2])
octets = bytes(numbers)
print(octets)
# b'\xfe\xff\xff\xff\x00\x00\x01\x00\x02\x00'
# В объекте octets хранится копия байтов, из которых составлены числа в мас-
# сиве numbers Это десять байт, представляющих пять коротких целых.
